import { ActiveModule, ParsedStyle, Theme } from '../types';
import { MODULE_DEFINITIONS, THEMES } from '../constants';
import { parse } from 'smol-toml';
import { load } from 'js-yaml';

// Helper to resolve color based on theme or hex
const resolveColor = (colorName: string, theme?: Theme): string => {
  if (!colorName) return 'inherit';
  
  // Hex code
  if (colorName.startsWith('#')) return colorName;

  // Normalize
  let normalized = colorName.toLowerCase();
  if (normalized === 'magenta') normalized = 'purple'; // Alias commonly used in ANSI/Starship

  // Theme color lookup
  if (theme && theme.colors[normalized as keyof typeof theme.colors]) {
    return theme.colors[normalized as keyof typeof theme.colors];
  }

  // Fallback for standard ANSI colors if no theme provided (though theme should always be provided)
  const defaultColors: Record<string, string> = THEMES[0].colors;
  return defaultColors[normalized as keyof typeof defaultColors] || colorName;
};

// Helper to parse a style string like "red bold bg:blue"
export const parseStyle = (styleStr: string, theme?: Theme): ParsedStyle => {
  const style: ParsedStyle = {};
  if (!styleStr) return style;

  const parts = styleStr.split(/\s+/);

  parts.forEach(part => {
    if (part === 'bold') style.fontWeight = 'bold';
    else if (part === 'italic') style.fontStyle = 'italic';
    else if (part === 'underline') style.textDecoration = 'underline';
    else if (part.startsWith('bg:')) {
      const color = part.replace('bg:', '');
      style.backgroundColor = resolveColor(color, theme);
    } else if (part.startsWith('fg:')) {
        const color = part.replace('fg:', '');
        style.color = resolveColor(color, theme);
    } else {
      // Assume fg color if not prefixed
      style.color = resolveColor(part, theme);
    }
  });

  return style;
};

// Render a single module's format string into an HTML structure
export const parseFormatString = (
  formatStr: string,
  variables: Record<string, string>,
  moduleStyle: string,
  theme?: Theme
) => {
  if (!formatStr) return [];

  let currentFormat = formatStr;

  // 1. Explicitly replace $style first, as it's a config variable, not a content variable
  // Using split/join instead of replaceAll for compatibility
  currentFormat = currentFormat.split('$style').join(moduleStyle || '');

  // 2. Substitute all other variables (content or nested formats like $symbol in character module)
  // We do this BEFORE parsing [ ]() structure so that variables can contain structure.
  Object.entries(variables).forEach(([key, val]) => {
    // Simple replacement. Note: This might potentially replace substrings in wrong places if
    // variable names are subsets of others, but standard Starship vars are usually distinct enough.
    // Using split/join instead of replaceAll for compatibility
    currentFormat = currentFormat.split(key).join(val || '');
  });

  const result: { text: string; style: ParsedStyle }[] = [];
  
  // Regex to capture [content](style) groups or plain text
  const regex = /\[(.*?)\]\((.*?)\)|([^\[]+)/g;
  
  let match;
  while ((match = regex.exec(currentFormat)) !== null) {
    if (match[1] !== undefined) {
      // We have a [content](style) block
      const content = match[1];
      const styleRaw = match[2];

      // We don't need to substitute variables inside here anymore because we did global substitution above.
      // However, we might want to trim empty segments if desired, but spaces are significant in prompt.

      if (content !== '') {
        result.push({
          text: content,
          style: parseStyle(styleRaw, theme)
        });
      }
    } else if (match[3] !== undefined) {
      // Plain text (outside of brackets)
      const content = match[3];
      
      result.push({
        text: content,
        style: {} // Default terminal text color
      });
    }
  }
  return result;
};

export const generateTOML = (
  modules: ActiveModule[],
  config?: {
    add_newline?: boolean;
    command_timeout?: number;
    scan_timeout?: number;
    right_format?: string;
    continuation_prompt?: string;
    palette?: string;
    palettes?: Record<string, Record<string, string>>;
  }
): string => {
  let toml = `# Starship Configuration\n# Generated by Starship Architect\n\n`;

  // Add global configuration options
  if (config?.add_newline !== undefined) {
    toml += `add_newline = ${config.add_newline}\n`;
  }
  if (config?.command_timeout !== undefined) {
    toml += `command_timeout = ${config.command_timeout}\n`;
  }
  if (config?.scan_timeout !== undefined) {
    toml += `scan_timeout = ${config.scan_timeout}\n`;
  }
  if (config?.palette) {
    toml += `palette = '${config.palette}'\n`;
  }
  if (toml.includes('=')) {
    toml += '\n';
  }

  const formatParts: string[] = [];

  modules.forEach(mod => {
    if (mod.type === 'line_break') {
        formatParts.push('$line_break');
        return;
    }

    formatParts.push(`$${mod.type}`);

    // Generate section
    toml += `[${mod.type}]\n`;
    toml += `disabled = ${mod.disabled}\n`;

    Object.entries(mod.properties).forEach(([key, value]) => {
      // Simple string escaping
      if (typeof value === 'string') {
        toml += `${key} = '${value.replace(/'/g, "\\'")}'\n`;
      } else if (typeof value === 'boolean') {
        toml += `${key} = ${value}\n`;
      } else if (typeof value === 'number') {
        toml += `${key} = ${value}\n`;
      } else {
        toml += `${key} = ${value}\n`;
      }
    });
    toml += '\n';
  });

  // Global format string
  toml = `format = """\n${formatParts.join('')}\n"""\n` +
         (config?.right_format ? `right_format = """\n${config.right_format}\n"""\n` : '') +
         (config?.continuation_prompt ? `continuation_prompt = '${config.continuation_prompt}'\n` : '') +
         '\n' + toml;

  // Add palettes if defined
  if (config?.palettes) {
    Object.entries(config.palettes).forEach(([paletteName, colors]) => {
      toml += `\n[palettes.${paletteName}]\n`;
      Object.entries(colors).forEach(([colorName, colorValue]) => {
        toml += `${colorName} = '${colorValue}'\n`;
      });
    });
  }

  return toml;
};

/**
 * Parses a TOML string back into ActiveModule[]
 * This is a best-effort parser for the specific subset of TOML used by Starship
 */
export const parseTOMLToModules = (tomlString: string): ActiveModule[] => {
  try {
    const parsed = parse(tomlString) as Record<string, any>;
    const format = parsed.format as string;
    
    let moduleOrder: string[] = [];
    
    if (format) {
      // Extract variables like $directory, $git_branch from format string
      // A simple split by '$' and cleanup
      moduleOrder = format.split('$')
        .map(s => s.trim())
        .filter(s => s.length > 0)
        // Remove any surrounding text/punctuation from the format string part to just get the module name
        // E.g. from "$directory\n" -> "directory"
        .map(s => s.replace(/[^a-zA-Z0-9_].*/g, '')); 
    } else {
      // Fallback: just take keys that match module definitions
      moduleOrder = Object.keys(parsed).filter(k => 
        MODULE_DEFINITIONS.some(def => def.name === k)
      );
    }

    const modules: ActiveModule[] = [];

    moduleOrder.forEach(modName => {
      if (modName === 'line_break') {
        modules.push({
          id: Math.random().toString(36).substr(2, 9),
          type: 'line_break',
          disabled: false,
          properties: {}
        });
        return;
      }

      const def = MODULE_DEFINITIONS.find(d => d.name === modName);
      // Even if definition is missing (custom module), we might want to support it loosely,
      // but for now let's stick to known modules to avoid breaking the UI.
      if (!def) return;

      const configProps = parsed[modName] || {};
      
      modules.push({
        id: Math.random().toString(36).substr(2, 9),
        type: modName,
        disabled: configProps.disabled === true,
        properties: {
          ...def.defaultProps,
          ...configProps
        }
      });
    });

    return modules;

  } catch (error) {
    console.error("Failed to parse TOML", error);
    return [];
  }
};

/**
 * Parses a Base16 YAML string into a Theme object
 */
export const parseBase16Theme = (yamlString: string): Theme | null => {
  try {
    const parsed: any = load(yamlString);
    if (!parsed || !parsed.palette) {
      console.warn("Invalid Base16 YAML format");
      return null;
    }

    const p = parsed.palette;
    
    return {
      name: parsed.name || 'Custom Theme',
      colors: {
        bg: p.base00,     // Default Background
        fg: p.base05,     // Default Foreground
        black: p.base01,  // Lighter Background (Used for status bars) / often used as ANSI Black
        red: p.base08,
        green: p.base0B,
        yellow: p.base0A,
        blue: p.base0D,
        purple: p.base0E,
        cyan: p.base0C,
        white: p.base07,  // Light Background / White
        orange: p.base09,
        gray: p.base03,   // Comments / Gray
      }
    };
  } catch (error) {
    console.error("Failed to parse Theme YAML", error);
    return null;
  }
};